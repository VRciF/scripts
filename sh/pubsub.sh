#!/bin/bash
##!/bin/bash -x
##set -o xtrace

# pubsub.sh is used to notify subscribers about published events
# thus pubsub.sh needs two directories: one directory is monitored for events,
# the other one is used to notify subscribers about those events
# 

usage()
{
cat << EOF
usage: $0 [-p PUBLISHDIR -s SUBSCRIBEDIR] [PUBLISH_AND_SUBSCRIBEDIR]

OPTIONS:
   -p      the directory where events will be published
   -s      the directory where subscribers wait to be notified about events

WORKFLOW:
pubsub.sh uses inotifywait to monitor PUBLISHDIR about the following file level events:
close regular file
open pipe

all other operations are ignored
as an example: if your software architecture requires to deliver an event named "net.host.up" AND "net.host.down"
you are free to create the directory structure PUBLISHDIR/net/host/up AND PUBLISHDIR/net/host/down
now if one opens an arbitrary file like PUBLISHDIR/net/host/up/t8374 (whose filename may be generated by tempnam()),
writes some data to it like "192.168.0.10"
and then closes the file
pubsub.sh detects the file change and searches for subscribers in the following order
SUBSCRIBEDIR/net/host/up/
SUBSCRIBEDIR/net/host/
SUBSCRIBEDIR/net/
SUBSCRIBEDIR/
the first level where executables are found will be used for event delivery
for example if there is a symlink to an executable called
SUBSCRIBEDIR/net/host/maintainhostlist.sh
the executable gets run using
SUBSCRIBEDIR/net/host/maintainhostlist.sh -e net/host/up PUBLISHDIR/net/host/up/t8374
if there are a bunch of executables in SUBSCRIBEDIR/net/host/ all of them get notified sorted by their filename

if a pipe is detected in PUBLISHDIR only the first matching subscriber is detected whose purpose shall be
to read the pipe
then pubsub.sh opens the pipe by itself and immediately closes to surely cause cleanup on the publisher side
(e.g. in case the subscriber couldnt open the pipe)

post processing after event delivery:    
1) the event file gets deleted
2) the 'find' command is used to find published events older than 30 seconds modified time
   (cause inotifywait suffers from a race condition on directory/file creation)
   if such an (old) pending event is found it gets delivered like the example above
3) the PUBLISHDIRs subdris get removed succesively by using rmdir command to clean up PUBLISHDIR  

EOF
}

#Time to wait for stuck processes before killing them                           
export ALARMTIME=10

PARENTPID=$$

PUBLISHERDIR=$1
SUBSCRIBEDIR=$1
while getopts "p:s:" OPTION
do
     case $OPTION in
         s)
             SUBSCRIBEDIR=$OPTARG
             if [ ! -d "$SUBSCRIBEDIR" ] ; then
                 echo "ERROR: not a directory" >&2;
                 usage
                 exit 1
             fi
             ;;
         p)
             PUBLISHERDIR=$OPTARG
             if [ ! "-d $PUBLISHERDIR" ] ; then
                 echo "ERROR: not a directory" >&2;
                 usage
                 exit 1
             fi
             ;;
         ?)
             usage
             exit 1
             ;;
     esac
done

if [ ! -d "$SUBSCRIBEDIR" ]; then
    echo "ERROR: SUBSCRIBEDIR missing" >&2
    usage
    exit 1
fi
if [ ! -d "$PUBLISHERDIR" ]; then
    echo "ERROR: PUBLISHERDIR missing" >&2
    usage
    exit 1
fi

SUBSCRIBEDIR=$(readlink -f "$SUBSCRIBEDIR")
PUBLISHERDIR=$(readlink -f "$PUBLISHERDIR")

function process {
    RELFILE=$1

    RELPATH=$(dirname $RELFILE)
    PATHITERATOR=$RELPATH
    while [ ${#PATHITERATOR} -gt 0 -a "$PATHITERATOR" != "." ]; do
        EXECUTED=0

        find "$SUBSCRIBEDIR/$PATHITERATOR" -maxdepth 1 -executable -type f | sort | while read EXECUTABLE;
        do
            EXECUTED=1

            $EXECUTABLE -e $RELPATH $PUBLISHERDIR/$RELFILE >/dev/null 2>&1
        done

        if [ $EXECUTED -eq 1 ]; then
            break;
        fi

        PATHITERATOR=$(dirname $PATHITERATOR)
    done

    rm "$PUBLISHERDIR/$RELFILE"
}  

# start a new process which checks if PARENTPID process exists calls touch every ALARMTIME on PUBLISHERDIR
(while kill -0 $PARENTPID >/dev/null 2>&1; do touch $PUBLISHERDIR; sleep $ALARMTIME; done) &

LASTFINDRUN=0

inotifywait -qrm -e CLOSE -e OPEN -e ATTRIB --format '%e;%w%f' "$PUBLISHERDIR" | while read LINE;
do
    EVENT=`echo "$LINE" | cut -d ';' -f1`

    RELPATH=${LINE:${#EVENT}}
    RELPATH=${RELPATH:1} # drop ';' character
    RELPATH=${RELPATH:${#PUBLISHERDIR}} # drop the publisher directory part, so we get only the relative path
    RELPATH=${RELPATH:1} # drop '/' character

    # if relpath length greater zero, the file exists, is not a directory, is not an executable
    # im testing for existence since process function can cause further inotify notifications on an already processed event
    # cause of eventually reading and thus closing the event file
    if [ ${#RELPATH} -gt 0 -a -e "$PUBLISHERDIR/$RELPATH" -a ! -d "$PUBLISHERDIR/$RELPATH" -a ! -x "$PUBLISHERDIR/$RELPATH" ]; then
	    if [[ -f "$PUBLISHERDIR/$RELPATH" && "$EVENT" == *CLOSE* ]]; then
	        process "$RELPATH"
	    else
	        if [[ -p "$PUBLISHERDIR/$RELPATH" && "$EVENT" == *OPEN* ]]; then
	            process "$RELPATH"
	        fi
	    fi
	fi

	NOW=$(date +%s)
	DIFFTIME=$(expr $NOW - $LASTFINDRUN)
	if [ $DIFFTIME -ge 10 ]; then
	    LASTFINDRUN=$NOW
	    find "$PUBLISHERDIR" -mmin 1 -type f -o -type p -print | while read FINDNAME;
	    do
	        ABSNAME=$(readlink -f "$PUBLISHERDIR/$FINDNAME")
	        FINDNAME=${ABSNAME:${#PUBLISHERDIR}}
	        FINDNAME=${FINDNAME:1} # drop '/' character

	        # ignore executables
	        if [ -x "$ABSNAME" ]; then
	            continue
	        fi

	        process "$FINDNAME"
	    done
	fi
done
